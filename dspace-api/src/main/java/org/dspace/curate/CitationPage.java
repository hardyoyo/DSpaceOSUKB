/**
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */
package org.dspace.curate;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;

import java.sql.SQLException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

import org.dspace.content.Bitstream;
import org.dspace.content.BitstreamFormat;
import org.dspace.content.Bundle;
import org.dspace.content.Collection;
import org.dspace.content.DCValue;
import org.dspace.content.DSpaceObject;
import org.dspace.content.Item;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Paragraph;

import com.itextpdf.text.pdf.PdfConcatenate;
import com.itextpdf.text.pdf.PdfPageLabels;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamper;
import com.itextpdf.text.pdf.PdfWriter;

import com.itextpdf.text.Rectangle;

/**
 * CitationPage
 *
 * This task is used to generate a cover page with citation information for text
 * documents and then to add that cover page to a PDF version of the document
 * replacing the originally uploaded document form the user's perspective.
 *
 * @author Ryan McGowan
 */

@Distributive
@Mutative
public class CitationPage extends AbstractCurationTask {

    private int status = Curator.CURATE_UNSET;
    private String result = null;
    /**
     * A StringBuilder to handle result string building process.
     */
    private StringBuilder resBuilder;
    /**
     * A set of MIME types that can have a citation page added to them. That is,
     * MIME types in this set can be converted to a PDF which is then prepended
     * with a citation page.
     */
    private static final Set<String> VALID_TYPES = new HashSet<String>(2);
    /**
     * Class Logger
     */
    private static Logger log = Logger.getLogger(CitationPage.class);
    /**
     * The name to give the bundle we add the cited pages to.
     */
    private static final String BUNDLE_NAME = "CITATION";
    private static final String OSU_HEADER_LINE = "This page was generated by"
        + " The Ohio State Univeristy Library's Knowledge Bank.";

    static {
        // Add valid format MIME types to set. This could be put in the Schema
        // instead.
        CitationPage.VALID_TYPES.add("application/pdf");
        CitationPage.VALID_TYPES.add("application/x-pdf");
    }

    /**
     * {@inheritDoc}
     * @see CurationTask#perform(DSpaceObject)
     */
    @Override
    public int perform(DSpaceObject dso) throws IOException {

        // Deal with status and result as well as call distribute.
        this.resBuilder = new StringBuilder();
        this.distribute(dso);
        this.result = this.resBuilder.toString();
        this.setResult(this.result);
        this.report(this.result);

        return this.status;
    }

    /**
     * {@inheritDoc}
     * @see AbstractCurationTask#performItem(Item)
     */
    @Override
    protected void performItem(Item item) throws SQLException {
        // Should return single element array with the ORIGINAL bundle
        Bundle[] bundles = item.getBundles("ORIGINAL");
        for (Bundle bundle : bundles) {
            Bitstream[] bitstreams = bundle.getBitstreams();
            // Loop through each file and generate a cover page for documents
            // that can be converted to a PDF.
            for (Bitstream bitstream : bitstreams) {
                BitstreamFormat format = bitstream.getFormat();

                //If bitstream is a document which can be converted to a PDF
                if (CitationPage.VALID_TYPES.contains(format.getMIMEType())) {
                    this.resBuilder.append(item.getHandle() + " - "
                            + bitstream.getName() + " is citable.");
                    try {
                        /*
                         * Process for adding cover page is as follows:
                         *  1. Load source file into PdfReader and create a
                         *     Document to put our cover page into.
                         *  2. Create cover page and add content to it.
                         *  3. Concatenate the coverpage and the source
                         *     document.
                         */
                        PdfReader source = new PdfReader(bitstream.retrieve());
                        String[] labels = PdfPageLabels.getPageLabels(source);
                        
                        //Determine the size of the first page so the
                        //citation page can be the same.
                        Rectangle pdfSize = source.getCropBox(1);
                        Document citedDoc = new Document(pdfSize);
                        File coverTemp = File.createTempFile(bitstream.getName(), ".cover.pdf");
                        //Need a writer instance to make changed to the
                        //document.
                        PdfWriter.getInstance(citedDoc, new FileOutputStream(coverTemp));

                        //Call helper function to add content to the coverpage.
                        CitationPage.generateCoverPage(citedDoc, new CitationMeta(item));

                        //Create reader from finished cover page.
                        PdfReader cover = new PdfReader(new FileInputStream(coverTemp));

                        //Concatente the finished cover page with the source
                        //document.
                        File citedTemp = File.createTempFile(bitstream.getName(), ".cited.pdf");
                        OutputStream citedOut = new FileOutputStream(citedTemp);
                        PdfConcatenate concat = new PdfConcatenate(citedOut);
                        concat.open();
                        concat.addPages(cover);
                        concat.addPages(source);

                        //Put all of our labels in from the orignal document.
                        if (labels != null) {
                            PdfPageLabels citedPageLabels = new PdfPageLabels();
                            citedPageLabels.addPageLabel(1, PdfPageLabels.EMPTY, "Citation Page");
                            log.debug("Printing arbitrary page labels.");
                            for (int i = 0; i < labels.length; i++) {
                                log.debug("Label for page: " + (i + 2) + " -> " + labels[i]);
                                citedPageLabels.addPageLabel(i + 2, PdfPageLabels.EMPTY, labels[i]);
                            }
                            concat.getWriter().setPageLabels(citedPageLabels);
                        }

                        //Close it up
                        concat.close();

                        //Now that we have a properly labeled, and concatenated
                        //document we fix up the internal metadata.
                        PdfStamper citedStamper = new PdfStamper(new PdfReader(
                                    new FileInputStream(citedTemp)), citedOut);

                        CitationPage.stampMeta(citedStamper, source);

                        //If the CITATION bundle already exists, remove
                        //it and start again.
                        Bundle[] citationBundles = item.getBundles(CitationPage.BUNDLE_NAME);
                        if (citationBundles.length > 0) {
                            //Remove all Bundles with the name CITATION
                            for (Bundle b : citationBundles) {
                                item.removeBundle(b);
                            }
                        }
                        Bundle citationBundle = item.createBundle(CitationPage.BUNDLE_NAME);

                        //Create an input stream form the temporary file
                        //that is the cited document and create a
                        //bitstream from it.
                        InputStream inp = new FileInputStream(citedTemp);
                        Bitstream citedBitstream = citationBundle.createBitstream(inp);
                        inp.close(); //Close up the temporary InputStream

                        //Setup a good name for our bitstream and make
                        //it the same format as the source document.
                        citedBitstream.setName("cited-" + bitstream.getName());
                        citedBitstream.setFormat(bitstream.getFormat());

                        this.resBuilder.append(" Added "
                                + citedBitstream.getName()
                                + " to the " + CitationPage.BUNDLE_NAME + " bundle.\n");

                        //Run update to propagate changes to the
                        //database.
                        item.update();
                        this.status = Curator.CURATE_SUCCESS;
                    } catch (Exception e) {
                        //Could be many things
                        e.printStackTrace();
                        StackTraceElement[] stackTrace = e.getStackTrace();
                        StringBuilder stack = new StringBuilder();
                        int numLines = Math.min(stackTrace.length, 12);
                        for (int j = 0; j < numLines; j++) {
                            stack.append("\t" + stackTrace[j].toString() + "\n");
                        }
                        if (stackTrace.length > numLines) {
                            stack.append("\t. . .\n");
                        }

                        log.error(e.toString() + " -> \n" + stack.toString());
                        this.resBuilder.append(", but there was an error generating the PDF.\n");
                        this.status = Curator.CURATE_ERROR;
                    }
                } else {
                    //bitstream is not a document
                    this.resBuilder.append(item.getHandle() + " - "
                            + bitstream.getName() + " is not citable.\n");
                    this.status = Curator.CURATE_SUCCESS;
                }
            }
        }
    }

    /**
     * Takes a DSpace {@link Bitstream} and uses its associated METADATA to
     * create a cover page.
     *
     * @param cDoc The cover page document to add cited information to.
     * @param cMeta
     *            METADATA retrieved from the parent collection.
     * @throws IOException
     * @throws DocumentException 
     */
    private static void generateCoverPage(Document cDoc, CitationMeta cMeta)
            throws IOException, DocumentException {
        // TODO: Fill in Cover Page creation.
        cDoc.open();

        cDoc.addHeader(cMeta.getCollection().getName() + ": "
                + cMeta.getItem().getName(), CitationPage.OSU_HEADER_LINE);
        //Iterate through METADATA and display each entry
        for (Map.Entry<String, String> entry : cMeta.getMetaData().entrySet()) {
            String val = entry.getValue();

            //Construct a nicely fomatted string.
            StringBuilder format = new StringBuilder("");
            format.append(entry.getKey() + ": "); 
            if (val.length() < 37) {
                format.append(val);
                format.append("\n");
                cDoc.add(new Paragraph(format.toString()));
            } else {
                format.append("\n");
                cDoc.add(new Paragraph(format.toString()));
                Paragraph valPara = new Paragraph(val);
                valPara.setLeading(0f, 1.1f);
                valPara.setSpacingAfter(0.5f);
                valPara.setIndentationLeft(36f);
                cDoc.add(valPara);
            }
        }

        cDoc.close();
   }

   /**
    * Adds METADATA, in the form of AcroFields, to the product from the source.
    * 
    * @param product The soon to be finished product.
    * @param source The orignal document being cited.
    */
   private static void stampMeta(PdfStamper product, PdfReader source) {
   }

    /**
     *
     */
    private class CitationMeta {
        private Bitstream pLogo;
        private Collection parent;
        private Map<String, String> metaData;
        private Item myItem;

        /**
         * Constructs CitationMeta object from an Item. It uses item specific
         * METADATA as well as METADATA from the owning collection.
         *
         * @param item An Item to get METADATA from.
         * @throws SQLException
         */
        public CitationMeta(Item item) throws SQLException {
            this.myItem = item;
            this.metaData = new HashMap<String, String>();
            //Get all METADATA from our this.myItem
            DCValue[] dcvs = this.myItem.getMetadata(Item.ANY, Item.ANY, Item.ANY, Item.ANY);
            //Put METADATA in a Map for easy access.
            for (DCValue dsv : dcvs) {
                String[] dsvParts = {dsv.schema, dsv.element, dsv.qualifier, dsv.language, dsv.authority};
                StringBuilder keyBuilder = new StringBuilder();
                for (String part : dsvParts) {
                    if (part != null && part != "") {
                        keyBuilder.append(part + '.');
                    }
                }
                //Remove the trailing '.'
                keyBuilder.deleteCharAt(keyBuilder.length() - 1);
                this.metaData.put(keyBuilder.toString(), dsv.value);
            }

            //Get METADATA from the owning Collection
            this.parent = this.myItem.getOwningCollection();
        }

        /**
         * Returns a map of the METADATA for the item associated with this
         * instance of CitationMeta.
         *
         * @return a Map of the METADATA for the associated item.
         */
        public Map<String, String> getMetaData() {
            return this.metaData;
        }

        public Item getItem() {
            return this.myItem;
        }

        public Collection getCollection() {
            return this.parent;
        }

        /**
         * {@inheritDoc}
         * @see Object#toString()
         * @return A string with the format:
         *  CitationMeta {
         *      CONTENT
         *  }
         *  Where CONTENT is the METADATA derived by this class.
         */
        @Override
        public String toString() {
            StringBuilder ret = new StringBuilder(CitationMeta.class.getName());
            ret.append(" {<br />\n\t");
            ret.append(this.parent.getName());
            ret.append("\n\t");
            ret.append(this.myItem.getName());
            ret.append("\n\t");
            ret.append(this.metaData);
            ret.append("\n}\n");
            return ret.toString();
        }
    }
}
